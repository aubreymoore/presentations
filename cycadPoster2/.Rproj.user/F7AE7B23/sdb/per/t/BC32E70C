{
    "contents" : "% NOTE -- ONLY EDIT Rgraphviz.Rnw!!!\n% Rgraphviz.tex file will get overwritten.\n%\n%\\VignetteIndexEntry{A New Interface to Plot Graphs Using Rgraphviz}\n%\\VignetteDepends{Rgraphviz, graph}\n%\\VignetteKeywords{tools, graphs}\n%\\VignettePackage{Rgraphviz}\n\n\\documentclass{article}\n\\usepackage{hyperref}\n\n\\newcommand{\\Rfunction}[1]{{\\texttt{#1}}}\n\\newcommand{\\Rpackage}[1]{{\\textit{#1}}}\n\\newcommand{\\Robject}[1]{{\\texttt{#1}}}\n\\newcommand{\\Rclass}[1]{{\\textit{#1}}}\n\\newcommand{\\R}[0]{{\\textit{R}}}\n\n\\newcommand{\\inclfig}[3]{%\n \\begin{figure}[htbp] \\begin{center}\n   \\includegraphics[width=#2]{#1}\n   \\caption{\\label{#1}#3}\n \\end{center} \\end{figure}\n}\n\n\\author{Florian Hahne}\n\\begin{document}\n\\SweaveOpts{concordance=TRUE}\n\\title{A New Interface to Render Graphs Using Rgraphviz}\n\\maketitle\n\\tableofcontents\n\n\\section{Overview}\nThis vignette shows how to use Rgraphviz's updated interface for\nrendering of graphs. For details on graph layout see the Vignette\n``How To Plot A Graph Using Rgraphviz''. Note that the design of the\ninterface is independent of graphviz, however no bindings to any other\ngraph layout software have been implemented so far.\n\n\n\n\n%---------------------------------------------------------------------\n\\section{Introduction}\n%---------------------------------------------------------------------\nThere are two distinct processes when plotting graphs:\n\\textit{layout}, which places nodes and edges in a (usually\ntwo-dimensional) space, and \\textit{rendering}, which is the actual\ndrawing of the graph on a graphics device. The first process is\ntypically the more computationally expensive one and relies on\nsophisticated algorithms that arrange the graph's components based on\ndifferent criteria. The arrangement of the nodes and edges depends on\nvarious parameters such as the desired node size, which again may be a\nfunction of the size of the node labels. Rendering of a graph is often\nsubject to frequent changes and adaptions, and it makes sense to\nseparate the two processes in the software implementation.  It is also\nimportant to realize that the process of getting a good layout is\niterative, and using default parameter settings seldom yields good\nplots.\n\nThe code available for doing graph layout in Bioconductor is based\nmainly on the \\textit{Graphviz} project and the \\textit{Boost graph\n  library}. However, because the rendering of a graph is separated\nfrom the layout, one can use other graph layout algorithms, as long as\nthe requirements of the rendering interface are met.\n\nIn the process of laying out a graph some amount of information is\ngenerated, mostly regarding the locations and dimensions of nodes on a\ntwo-dimensional plane and the trajectories of the edges. Bioconductor\n\\Rclass{graph} objects now contain a slot \\Robject{renderInfo} to hold\nthis information. The typical workflow of a graph layout is to pass a\ngraph object to the layout function, which returns another graph\nobject containing all the necessary information for subsequent\nrendering. The process of calling a layout algorithm is encapsulated\nin the \\Rfunction{layoutGraph} function. Calling this function without\nany further arguments will result in using one of the \\textit{Graphviz}\nlayout algorithms via the the \\Rpackage{Rgraphviz} package. We assume\na knowledge of graph layout and the available \\textit{Graphviz}\noptions in the remainder of this Vignette and will mostly deal with the\nrendering part, here.\n\nThe rendering of a graph relies solely on \\R{}'s internal plotting\ncapabilities. As for all other plotting functions in \\R{}, many\nparameters controlling the graphical output can be tuned. However,\nbecause there are several parts of a graph one might want\nto modify (e.g., nodes, edges, captions), setting the graphical\nparameters is slightly more complex than for other plots. We have\nestablished a hierarchy to set global defaults,\ngraph-specific parameters, and settings that apply only to\nindividual rendering operations.\n\n\nTo demonstrate the new rendering interface we first generate a graph\nusing the \\Rpackage{graph} package and lay it out using the default\n\\textit{Graphviz} dot layout.\n%\n<<createGraph1, fig=TRUE>>=\nlibrary(\"Rgraphviz\")\nset.seed(123)\nV <- letters[1:10]\nM <- 1:4\ng1 <- randomGraph(V, M, 0.2)\ng1 <- layoutGraph(g1)\nrenderGraph(g1)\n@\n\n\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\\section{Default rendering parameters}\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThere is a hierarchy to set rendering parameters for a graph. The\nlevels of this hierarchy are\n\\begin{enumerate}\n  \n\\item{The session:} These are the defaults that will be used for a\n  parameter if not set somewhere further down the hierarchy. You can\n  change the session defaults at any time using the function\n  \\Rfunction{graph.par}.\n  \n\\item{Rendering operation:} Defaults can be set for a single rendering\n  operation, that is, for a single call to \\Rfunction{renderGraph}\n  using its \\Robject{graph.pars} argument.\n  \n\\item{Individual nodes or edges:} Parameters for individual nodes or\n  edges in a graph object can be set using the\n  \\Rfunction{nodeRenderInfo} and \\Rfunction{edgeRenderInfo} functions.\n  \n\\end{enumerate}\n\nNote that all parameters set in \\Rfunction{renderGraph's}\n\\Robject{graph.pars} argument are transient, whereas setting\nsession-wide parameters will affect all subsequent rendering\noperations. Setting parameters via the \\Rfunction{nodeRenderInfo} and\n\\Rfunction{edgeRenderInfo} functions affects the individual graph\nobjects, and these changes will obviously be retained in all\nsubsequent layout or rendering operations of that particular graph.\n\n\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\\subsection{Default node parameters}\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nWe now use our example graph to further explore these options. Let's\nstart with the nodes: We want to fill all our nodes with a gray color\nand use a red color for the node names. Since this should be applied\nto all nodes, we set a global rendering parameter using\n\\Rfunction{graph.par}:\n<<bgandfontcol, fig=TRUE>>=\ngraph.par(list(nodes=list(fill=\"lightgray\", textCol=\"red\")))\nrenderGraph(g1)\n@\n\nSetting a session-wide parameter has side-effects for all subsequent\nrendering operations, and we will soon see how to archive the same\nsetting using the \\Rfunction{nodeRenderInfo} function. \n\nNote that \\Rfunction{graph.par} takes as single argument a list of\nrendering parameters. There are three different types of parameters\nthe user might want to set: nodewide parameters, edgewide parameters\nand parameters that control features of the whole graph. Accordingly,\nthe parameters list passed to \\Rfunction{graph.par} may contain the\nlist items \\Robject{nodes}, \\Robject{edges} and \\Robject{graph}. Each\nof these list items can again be a list of available plotting\nparameters. In our example, the parameters are \\Robject{fill} and\n\\Robject{textCol}. All currently available node parameters are:\n\n\\begin{itemize}\n\\item{col:} {the color of the line drawn as node border. Defaults to\n  \\Robject{black}.}\n\\item{lty:} {the type of the line drawn as node border. Defaults to\n  \\Robject{solid}. Valid values are the same as for the R's base\n  graphic parameter \\Robject{lty}.}\n\\item{lwd:} {the width of the line drawn as node border. Defaults to\n  \\Robject{1}.Note that the underlying low level plotting functions\n  do not support vectorized \\Robject{lwd} values. Instead, only the\n  first item of the vector will be used.}\n\\item{fill:} {the color used to fill a node. Defaults to\n  \\Robject{transparent}.}\n\\item{textCol:}{the font color used for the node labels. Defaults to\n  \\Robject{black}.}\n\\item{fontsize:} {the font size for the node labels in\n  points. Defaults to \\Robject{14}. Note that the fontsize will be\n  automatically adjusted to make sure that all labels fit their\n  respective nodes. You may want to increase the node size by\n  supplying the appropriate layout parameters to \\textit{Graphviz} in\n  order to allow for larger fontsizes.}\n\\item{cex:} {Expansion factor to further control the fontsize. As\n  default, this parameter is not set, in which case the fontsize will\n  be clipped to the node size. This mainly exists to for consistency\n  with the base graphic parameters and to override the clipping of\n  fontsize to nodesize.}\n\\item{shape:} {This is not really a graphical parameter. See Section\n    \\ref{layoutpars} for details.}\n\n\\end{itemize}\n\nIn the next code chunk we set the defaults for all remaining node parameters:\n<<nodepardefs, fig=TRUE>>=\ngraph.par(list(nodes=list(col=\"darkgreen\", lty=\"dotted\", lwd=2, fontsize=6)))\nrenderGraph(g1)\n@ \n\nSimilar to \\R{}'s base \\Rfunction{par} function, the original values\nof a modified paramter are returned by \\Rfunction{graph.par} and you\nmay want to assign them to an object in order to later revert your\nchanges.\n\nA useful feature when plotting graphs is to control the shape of the\nnodes. However, shapes have an impact on the ideal location of nodes\nand, even more so, the edges between them. Hence, the layout algorithm\nneeds to be re-run whenever there are changes in node shapes. In\nSection \\ref{layoutpars} we will learn how to control node shapes and\nalso some features of the edges.\n\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\\subsection{Default edge parameters}\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nNow, let's take a look at the parameters that control the appearence\nof edges. They are:\n\n\\begin{itemize}\n\\item{col:} {the color of the edge line. Defaults to \\Robject{black}.}\n\\item{lty:} {the type of the edge line. Defaults to\n  \\Robject{solid}. Valid values are the same as for the R's base\n  graphic parameter \\Robject{lty}.}\n\\item{lwd:} {the width of the edge line. Defaults to \\Robject{1}.}\n\\item{textCol:}{the font color used for the edge labels. Defaults to\n  \\Robject{black}.}\n\\item{fontsize:} {the font size for the edge labels in points. Defaults\n  to \\Robject{14}.}\n\\item{cex:} {Expansion factor to further control the fontsize. This\n  mainly exists to be consistent with the base graphic parameters.}\n\\item{arrowhead, arrowtail} {Again, not really a plotting\n    parameter. Section \\ref{layoutpars} provides details. }\n\\end{itemize}\n\nFirst, we set some attributes that control the edge lines.\n<<edgepardefs, fig=TRUE>>=\ngraph.par(list(edges=list(col=\"lightblue\", lty=\"dashed\", lwd=3)))\nrenderGraph(g1)\n@ \n\nIn order to show the effects of the edge label parameters, we first\nhave to add such labels. \\Rfunction{layoutGraph} will pass them on to\n\\textit{Graphviz} when they are specified as \\Robject{edgeAttrs}:\n<<labels, fig=TRUE>>=\nlabels <- edgeNames(g1)\nnames(labels) <- labels\ng1 <- layoutGraph(g1, edgeAttrs=list(label=labels))\nrenderGraph(g1)\n@\n\nNow we can start tweaking them:\n<<tweaklabesl, fig=TRUE>>=\ngraph.par(list(edges=list(fontsize=18, textCol=\"darkred\")))\nrenderGraph(g1)\n@\n\n\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\\subsection{Default graphwide parameters}\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSome features of a graph are not really attributes of either nodes or\nedges. They can be controlled through the graphwide rendering\nparameters:\n\n\\begin{itemize}\n\\item{main:} {text that is plotted as the main title. Unless set\n  explicitely, no title will be plotted.}\n\\item{sub:} {text that is plotted as subtitle at the bottom of the\n  graph. Unless set explicitely, no subtitle will be plotted.}\n\\item{col.main:} {the font color used for the title. Defaults\n  to \\Robject{black}.}\n\\item{cex.main:} {Expansion factor for the fontsize used for the\n  title. Defaults to \\Robject{1.2}}\n\\item{col.sub:} {the font color used for the subtitle. Defaults\n  to \\Robject{black}.}\n\\item{cex.sub:} {Expansion factor for the fontsize used for the\n  subtitle. Defaults to \\Robject{1}}\n\\end{itemize}\n\n\nHere, we add both a title and a subtitle to the plot.\n<<graphpardefs, fig=TRUE>>=\ngraph.par(list(graph=list(main=\"A main title...\", \n               sub=\"... and a subtitle\", cex.main=1.8, \n               cex.sub=1.4, col.sub=\"gray\")))\nrenderGraph(g1)\n@ \n\nOf course we could set all graph-, node-, and edgewide parameters in\none single call to \\Rfunction{graph.par}. Instead of defining global\nsettings with \\Rfunction{graph.par} we could also provide a list with\nthe same structure to \\Rfunction{renderGraph} through its\n\\Robject{graph.pars} argument. Those will only be applied in the\nrespective rendering operation, whereas options set using the function\n\\Rfunction{graph.par} are retained throughout the whole \\R{} session.\n\n\n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\\section{Parameters for individual nodes/edges} \n%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nIn many cases we don't want to globally change certain parameters for\nall nodes or edges, but rather do this selectively to highlight\nindividual nodes/edges or subsets thereof. To this end, parameters for\nindividual nodes and edges can be set using the\n\\Rfunction{nodeRenderInfo} and \\Rfunction{edgeRenderInfo}\nfunctions. Both \\Rfunction{nodeRenderInfo} and\n\\Rfunction{edgeRenderInfo} are replacement functions that operate\ndirectly on the \\Rclass{graph} object. For completeness,\n\\Rfunction{graphRenderInfo} is the function that can be used to\ncontrol the graph-wide attributes (like captions and subtitles). When\nyou change a parameter in the \\Rclass{graph} object this will be\ncarried on across all further rendering and layout operations. The\nsettings made by \\Rfunction{edgeRenderInfo} and\n\\Rfunction{nodeRenderInfo} take precedence over all other default\nsettings.\n\nThe parameters to be set have to be given as named lists, where each\nlist item can contain named vectors for certain options. For example,\nthe following code sets the fill color of nodes \\Robject{a} and\n\\Robject{b} to \\Robject{yellow}.\n<<nodePars, fig=TRUE>>=\nnodeRenderInfo(g1) <- list(fill=c(a=\"lightyellow\", b=\"lightyellow\"))\nrenderGraph(g1) \n@ \n\nThe names of the vectors have to match the node or edge names of the\ngraph. Node names are straightforward (the result of calling the\nfunction \\Rfunction{nodes} on a \\Rclass{graph} object), however edge\nnames are made up of the names of the connected nodes separated by\n\\verb+~+, the tilde symbol.  An edge between nodes \\verb+a+ and\n\\verb+b+ would be named \\verb+a~b+. For a directed graph \\verb+a~b+ is\nthe edge fom \\verb+a+ to \\verb+b+, and \\verb+b~a+ is the edge from\n\\verb+b+ to \\verb+a+. For undirected graphs the two are\nequivalent. \\Rfunction{edgeNames} returns the names of all edges in a\ngraph. The following code changes the line type of the edges between\nnodes \\verb+b+ and \\verb+f+ and nodes \\verb+b+ and \\verb+h+ to\n\\Robject{solid} and their line color to \\Robject{orange}.\n\n<<edgePars, fig=TRUE>>=\nedgeRenderInfo(g1) <- list(lty=c(\"b~f\"=\"solid\", \"b~h\"=\"solid\"),\n                          col=c(\"b~f\"=\"orange\", \"b~h\"=\"orange\"))\nrenderGraph(g1)\n@ \n\nChanges in the rendering of specific nodes or edges is often motivated\nby certain classes or features they represent and we don't want to set\nthis manually but rather use a programmatic approach:\n<<programParms, fig=TRUE>>=\nbaseNodes <- letters[1:4]\nfill <- rep(\"lightblue\", length(baseNodes))\nnames(fill) <- baseNodes\nnodeRenderInfo(g1) <- list(fill=fill)\nrenderGraph(g1)\n@ \n\nBoth \\Rfunction{nodeRenderInfo} and\n\\Rfunction{edgeRenderInfo} also allow to set parameters for all edges\nor nodes of the graph at once. The syntax is simple: instead of a\nnamed vector one can pass a scalar for a given parameter. This value\nwill then be assigned to all available nodes or edges.\n\n<<setallatonce, fig=TRUE>>=\nnodeRenderInfo(g1) <- list(lty=1)\nedgeRenderInfo(g1) <- list(lty=1, lwd=2, col=\"gray\")\nrenderGraph(g1)\n@ \n\nThe easiest way to set an attribute back to its default (the session\ndefault if it has been set) is to pass in a \\Robject{NULL} list item\nvia the respective setter function.\n\n<<reset, fig=TRUE>>=\nnodeRenderInfo(g1) <- list(fill=list(b=NULL, d=NULL))\nrenderGraph(g1)\n@ \n\n\n\\section{Graphical parameters that affect the layout}\\label{layoutpars}\nAs mentioned before, some graphical parameters are somewhat on the\nborder between graph layout and graph rendering. The shape of the node\nfor example does not drastically affect it's location, however the\nlayout of the edges pointing to and from this node might slightly\nchange. Since manipulating these attributes is a frequent operation in\ngraph plotting, we decided to make them available through the\nrendering interface.\n\n\\subsection{Node shapes}\nNode shapes can be set using the \\Robject{shape} parameter. Currently,\nthe rendering function supports the following shape types:\n\n\\begin{itemize}\n\\item{circle} {this is the default value. Circular nodes are not\n    affected by changes in width or height, the algorithm will\n    always use a quadratic bounding box}\n\\item{ellipse} {this shape allows for differences in width and\n    height. Elliptical nodes often fit node labels better without\n    wasting too much real estate. }\n\\item{box, rectangle} {A rectangular node.}\n\\item{triangle}  {this  is  currently  only partly  supported  due  to\n    restrictions in the Graphviz  interface. Edges locations might not\n    be optimal when triangular nodes are used.}\n\\item{plaintext} {no node shape at all, only the node labels are\n    plotted.}\n\\end{itemize}\n\nLets change all nodes shapes to ellipses first and then try out some\nof the remaining shapes on single nodes. Because of their impact on\nthe overall layout, we have to run \\Rfunction{layoutGraph} again in\norder for these modifications to work.\n<<nshape, fig=TRUE>>=\nnodeRenderInfo(g1) <- list(shape=\"ellipse\")\nnodeRenderInfo(g1) <- list(shape=c(g=\"box\", i=\"triangle\", \n                                   j=\"circle\", c=\"plaintext\"))\ng1 <- layoutGraph(g1)\nrenderGraph(g1)\n@ \n\nTo provide even more flexibility, the values of the \\Robject{shape}\nattributes can also be user-defined functions. \\Rfunction{renderGraph}\nwill call these functions internally, passing on a number of\nparameters. The most important parameter is a two-by-two matrix giving\nthe bounding box of the respective node. This information should be\nused in the self-defined node plotting function to control the node\nlocation and also its size. No clipping ever occurs to this bounding\nbox, and if the user decides to extend the node size beyond these\nlimits, overplotting with other nodes or edges is very likely. The\nadditional parameters that are passsed on to the function are:\n\\Robject{labelX}, \\Robject{labelY}, \\Robject{fill}, \\Robject{col},\n\\Robject{lwd}, \\Robject{lty}, \\Robject{textCol}, \\Robject{style},\n\\Robject{label} and \\Robject{fontsize}. Consult the help pages of the\n\\Rfunction{layoutGraph} and \\Rfunction{renderGraph} functions for\ndetails.\n\nAs an example we will use a function that creates random thermometer\nplots as node glyphs in the following code chunk. Note that we make\nuse of the \\Robject{...} argument to catch all of the passed\nparameters that we don't really need. We also remove the edge labels\nfrom the graph to tidy it up a little.\n<<userDefinedNode, fig=TRUE>>=\nedgeRenderInfo(g1) <- list(label=NULL)\n\nmyNode <- function(x, col, fill, ...)\nsymbols(x=mean(x[,1]), y=mean(x[,2]), thermometers=cbind(.5, 1,\nrunif(1)), inches=0.5,\nfg=col, bg=fill, add=TRUE)\n\nnodeRenderInfo(g1) <- list(shape=list(d=myNode, f=myNode), \n                           fill=c(d=\"white\", f=\"white\"),\n                           col=c(d=\"black\", f=\"black\"))\ng1 <- layoutGraph(g1)\nrenderGraph(g1)\n@ \n\n\\subsection{Edge arrowheads and arrowtails}\n\nSimilar to the control of node shapes, \\Rfunction{renderGraph}\nsupports different types of shapes for the tips of the edges. In\nundirected graphs this feature is not really supported because edges\nare merely connecting nodes, they don't convey any information about\ndirection. We can change the mode of our sample graph to\n\\Robject{directed} to further explore this feature.\n<<changeMode>>=\nedgemode(g1) <- \"directed\"\n@ \n\nThe valid values for both arrowheads and arrowtails of the edges are\n\\Robject{open}, \\Robject{normal}, \\Robject{dot}, \\Robject{odot},\n\\Robject{box}, \\Robject{obox}, \\Robject{tee}, \\Robject{diamond},\n\\Robject{odiamond} and \\Robject{none}. The little helper function\n\\Rfunction{edgeNames} can be used to list all available edge names.\n<<arrowheads, fig=TRUE>>=\nedgeRenderInfo(g1) <- list(arrowhead=c(\"e~h\"=\"dot\", \"c~h\"=\"odot\",\n                                       \"a~h\"=\"diamond\", \"b~f\"=\"box\",\n                                       \"a~b\"=\"box\", \"f~h\"=\"odiamond\"),\n                           arrowtail=\"tee\")\ng1 <- layoutGraph(g1)\nrenderGraph(g1)\n@ \n\nThere is also the option to pass a user-defined function as\n\\Robject{arrowhead} or \\Robject{arrowtail} parameter to gain even more\ncontrol. Similar to node shapes, the function has to be able to deal\nwith several parameters: The first parameter gives the center of the\nlocation of the arrowhead or tail. The additional parameters\n\\Robject{col}, \\Robject{lwd} and \\Robject{lty} are color and line\nstyles defined for the edges.\n<<userDefinedEdge, fig=TRUE>>=\nmyArrows <- function(x, ...)\n{\nfor(i in 1:3)\npoints(x,cex=i, ...)\n}\nedgeRenderInfo(g1) <- list(arrowtail=c(\"c~h\"=myArrows))\ng1 <- layoutGraph(g1)\nrenderGraph(g1)\n@\n\n\n<<reset, echo=FALSE, results=hide>>=\n# reset the defaults\ngraph.par(graph:::.default.graph.pars())\n@ \n\n\\section{Sessioninfo}\n\nThis document was produced using\n<<echo=FALSE>>=\nsessionInfo()\n@ \ntogether with version \\Sexpr{graphvizVersion()} of graphviz.\n\n\n\\end{document}\n",
    "created" : 1384572622671.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2533194808",
    "id" : "BC32E70C",
    "lastKnownWriteTime" : 1384578501,
    "path" : "~/Presentations/cycadPoster2/newRgraphvizInterface.Rnw",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "sweave"
}